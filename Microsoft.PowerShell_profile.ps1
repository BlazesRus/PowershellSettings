<#
# Reusable PowerShell Profile Configuration for Better GitHub Copilot Integration
# Enhanced with Node.js and pnpm support
# Original version generated by James Armstrong(github.com/BlazesRus) 
# with GitHub Copilot assistance for Powershell 7 
# (reusablable version generated with Microsoft Copilot assistance)
# - Place this script at: $PROFILE (e.g. $HOME\Documents\PowerShell\Microsoft.PowerShell_profile.ps1)
# or inside project as a terminal setting
# - Customize only under ‚Äú# Configuration‚Äù as needed.
#>

if($env:USERPROFILE){
  #Write-Host "`$env:USERPROFILE: [$env:USERPROFILE]"
}
if($env:HOME){
  #Write-Host "`$env:HOME: [$env:HOME]"
  if (-not $HOME) { $HOME = $env:HOME }
}
elseif($HOME){
 #Write-Host "`$HOME: [$HOME]"
}
elseif($env:USERPROFILE){ $HOME = $env:USERPROFILE }
else { Write-Host "Home variable does not exist" }


# In your profile script
#  - On PS5.1: Test-Path variable:IsWindows is false ‚Üí -not false = true ‚Üí Windows
#  - On PS Core/Windows: Test-Path true AND $IsWindows true ‚Üí true
#  - On PS Core/Linux/macOS: Test-Path true AND $IsWindows false ‚Üí false

$runningOnWindows = $PSHOME -match '\\WindowsPowerShell\\'

# UTF-8 encoding configuration for Windows
[Console]::OutputEncoding = [Text.UTF8Encoding]::new()
[Console]::InputEncoding = [Text.UTF8Encoding]::new()
# Make all Out-File/Set-Content/Add-Content/Export-Csv use UTF-8 without BOM
$PSDefaultParameterValues['*:Encoding'] = 'utf8NoBOM'
$PSDefaultParameterValues['Out-File:Encoding']      = 'utf8NoBOM'
$PSDefaultParameterValues['Set-Content:Encoding']    = 'utf8NoBOM'
$PSDefaultParameterValues['Add-Content:Encoding']    = 'utf8NoBOM'
$PSDefaultParameterValues['Export-Csv:Encoding']     = 'utf8NoBOM'
$PSDefaultParameterValues['ConvertTo-Json:Depth']    = 5  # JSON depth tweak, optional

if ($runningOnWindows) {
  if ($PSVersionTable.PSEdition -eq 'Desktop') {
    try { chcp 65001 | Out-Null } catch {}
  }

  if ($env:LANG -match '^en' -or $lang -eq 'en') {
    $env:LANG = "en_US.UTF-8"
  }
}
else {
  # On *nix, ensure LANG starts with "en"
  if ($env:LANG -match '^en') {
    $env:LANG = "en_US.UTF-8"
  }
}

# Ensure prompt loads quickly to prevent Copilot timing out
$ErrorActionPreference = "SilentlyContinue"

### Utility: Find-Executable ###

function Resolve-ShimTarget {
  param([string]$ShimPath)

  $folder = Split-Path $ShimPath -Parent
  switch -Wildcard ($ShimPath) {
    '*.cmd' {
      $content = Get-Content $ShimPath -Raw
      if ($content -match '"%~dp0\\([^"]+\.exe)"') {
        return Join-Path $folder $matches[1]
      }
      break
    }
    '*.ps1' {
      foreach ($line in Get-Content $ShimPath) {
        if ($line -match "Join-Path \$basedir '([^']+\.exe)'") {
          return Join-Path $folder $matches[1]
        }
      }
      break
    }
  }

  return $null
}

# 1) Locate the actual .exe or .cmd shim
function Find-ExecutablePath {
  param(
    [Parameter(Mandatory)] [string]   $Name,
    [string[]]                       $SearchPaths
  )

  # a) Anything on PATH already?
  if ($c = Get-Command $Name -ErrorAction SilentlyContinue) {
    return $c.Path
  }

  # b) Fallback scan
  $exts = if ($runningOnWindows) { '.cmd','.exe' } else { '' }
  foreach ($ext in $exts) {
    foreach ($dir in $SearchPaths) {
      $f = Join-Path $dir "$Name$ext"
      if (Test-Path $f) { return (Resolve-Path $f).Path }
    }
  }
  return $null
}

# 2) Extract the folder
function Find-ExecutableFolder {
  param(
    [Parameter(Mandatory)] [string]   $Name,
    [string[]]                       $SearchPaths
  )

  $path = Find-ExecutablePath -Name $Name -SearchPaths $SearchPaths
  return if ($path) { Split-Path $path -Parent } else { $null }
}

### Configuration ###
# List of potential Node/pnpm root paths to scan (in order)
$Global:NodeSearchPaths = @(
  "$HOME\AppData\Roaming\npm",                           # Windows npm default(Most likely location)
  (npm root -g | Split-Path -Parent),                   # npm global modules root
  "$env:ProgramFiles\nodejs",                            # Node installer
  "/usr/local/bin",                                      # macOS/Linux default
  "/usr/bin"
)

$Global:pnpmSearchPaths = @(
  "$HOME\AppData\Local\pnpm",                           # Windows npm default (Most likely location)
  "/usr/local/bin",                                      # macOS/Linux default
  "/usr/bin"
)

# Node.js and pnpm Path Configuration
# Add Node.js and pnpm to PATH if not already present

$nodePath   = Find-ExecutablePath   -Name node  -SearchPaths $Global:NodeSearchPaths
$pnpmPath   = Find-ExecutablePath   -Name pnpm  -SearchPaths $Global:pnpmSearchPaths
$nodeFolder = Find-ExecutableFolder -Name node  -SearchPaths $Global:NodeSearchPaths
$pnpmFolder = Find-ExecutableFolder -Name pnpm  -SearchPaths $Global:pnpmSearchPaths

# 5) Also include npm‚Äôs true global bin (where shims live)
try { $npmBin = (npm bin -g).Trim() } catch {}

# new: detect pnpm‚Äôs global-bin folder
try {
  $pnpmGlobalBin = (pnpm bin -g).Trim()
} catch {
  $pnpmGlobalBin = $null
}

### Locate wasm-opt in npm/pnpm Binaryen ###
# Include Node/npm/pnpm global bins plus typical Binaryen package folders
$Global:WasmOptSearchPaths = @(
  $pnpmGlobalBin,
  $npmBin,
  # Look inside a binaryen package if installed by pnpm/npm
  (Join-Path $pnpmGlobalBin 'node_modules\binaryen\bin'),
  (Join-Path $npmBin      'node_modules\binaryen\bin'),
  "$env:ProgramFiles\binaryen\bin",
  "$HOME\.cargo\bin",
  "/usr/local/bin",
  "/usr/bin"
)

$wasmOptPath   = Find-ExecutablePath   -Name wasm-opt  -SearchPaths $Global:WasmOptSearchPaths

# Cache it once
$script:WasmOptExe = $wasmOptPath
if ($script:WasmOptExe) {
  Write-Host "Found wasm-opt at: $script:WasmOptExe" -ForegroundColor Green
} else {
  Write-Host "‚ö†Ô∏è  wasm-opt not found in pnpm/npm Binaryen paths" -ForegroundColor Yellow
}

function Invoke-WasmOpt {
  param(
    [string[]]$Flags
  )
  if (-not $script:WasmOptExe) {
    Write-Error 'wasm-opt not found in your PATH or search paths.'
    return
  }
  & $script:WasmOptExe @Flags
}

# alias for brevity
Set-Alias wasmopt Invoke-WasmOpt -Force

# 6) Prepend each folder once
@($nodeFolder,$pnpmFolder,$npmBin, $pnpmGlobalBin) |
  Where-Object { $_ -and (Test-Path $_) } |
  ForEach-Object {
    if ($env:PATH -notmatch [regex]::Escape($_)) {
      $env:PATH = "$_;$env:PATH"
      Write-Host "Added to PATH: $_" -ForegroundColor Green
    }
  }

# Then in wrapper:
function Invoke-Node { & $script:NodeExe @Args }
function Invoke-Pnpm { & $script:PnpmExe @Args }

if (-not (Get-Command node -CommandType Any -ErrorAction SilentlyContinue)) {
    Set-Alias node  Invoke-Node  -Force
}
if (-not (Get-Command pnpm -CommandType Any -ErrorAction SilentlyContinue)) {
  Set-Alias pnpm Invoke-Pnpm -Force
}

# Set up shell integration markers for better command detection
function prompt {
    # Add shell integration markers that help Copilot detect command completion

    # ANSI sequences
    $ESC = [char]27
    $BEL = [char]7

    # Command started marker
    Write-Host "$ESC]133;C$BEL" -NoNewline

    # Standard prompt
    $path = Get-Location
    $gitBranch = ""

    # Quick git branch detection (if in git repo)
    if (Test-Path ".git") {
        try {
            $gitBranch = " ($(git branch --show-current 2>$null))"
        } catch {}
    }

    # Command finished marker
    Write-Host "$ESC]133;D;$LASTEXITCODE$BEL" -NoNewline

    return "PS $path$gitBranch> "
}

# Improve command completion detection
if ($null -ne $script:ExitEvent) {
  Unregister-Event -SubscriptionId $script:ExitEvent
}

$script:ExitEvent = Register-EngineEvent -SourceIdentifier PowerShell.Exiting -Action {
    $ESC = [char]27
    $BEL = [char]7
    Write-Host "$ESC]133;D;$LASTEXITCODE$BEL" -NoNewline
}

# Set console title for better terminal identification
$Host.UI.RawUI.WindowTitle = "PowerShell - GitHub Copilot Enhanced (Node.js Ready)"

# Improve readline experience
if (Get-Module -ListAvailable PSReadLine) {
    Import-Module PSReadLine
    Set-PSReadLineOption -PredictionSource History
    Set-PSReadLineOption -HistorySearchCursorMovesToEnd
    Set-PSReadLineKeyHandler -Key Tab -Function Complete
}

# Quick function to signal command completion to Copilot
function Send-CompletionSignal {
    $ESC = [char]27
    $BEL = [char]7
    Write-Host "$ESC]133;D;0$BEL" -NoNewline
    Write-Host "`nCommand completed successfully." -ForegroundColor Green
}

# Alias for easy use
Set-Alias -Name "done" -Value "Send-CompletionSignal"

# Test Node.js and pnpm availability on profile load
if ($Host.Name -eq 'ConsoleHost') {
  Write-Host "PowerShell profile loaded - GitHub Copilot integration enhanced" -ForegroundColor Cyan

  # Verify Node.js and pnpm are working
  try {
    $nodeVersion = & $script:NodeExe --version
    if ($nodeVersion) {
      Write-Host "‚úÖ Node.js $nodeVersion is available" -ForegroundColor Green
    } else {
      Write-Host "‚ö†Ô∏è  Node.js command may need troubleshooting" -ForegroundColor Yellow
    }
  } catch {
    try {
      #Assuming Shim is caught so extracting the real .exe/.cmd
      $shim = (Get-Command node).Path
      $real = Resolve-ShimTarget $shim
      $script:NodeExe = $real
      Set-Alias node  Invoke-Node  -Force
      $nodeVersion = & $script:NodeExe --version
      if ($nodeVersion) {
        Write-Host "‚úÖ Node.js $nodeVersion is available" -ForegroundColor Green
      } else {
        Write-Host "‚ö†Ô∏è  Node.js command may need troubleshooting" -ForegroundColor Yellow
      }
    }
    catch {
      Write-Host "‚ö†Ô∏è  Node.js is not working: $_" -ForegroundColor Yellow
    }
  }

  try {
    $pnpmVersion = & $script:PnpmExe --version
    if ($pnpmVersion) {
      Write-Host "‚úÖ pnpm $pnpmVersion is available" -ForegroundColor Green
    } else {
      Write-Host "‚ö†Ô∏è  pnpm command may need troubleshooting" -ForegroundColor Yellow
    }
  } catch {
    try {
      #Assuming Shim is caught so extracting the real .exe/.cmd
      $shim = (Get-Command pnpm).Path
      $real = Resolve-ShimTarget $shim
      $script:PnpmExe = $real
      Set-Alias pnpm  Invoke-Pnpm  -Force
      $pnpmVersion = & $script:PnpmExe --version
      if ($pnpmVersion) {
        Write-Host "‚úÖ pnpm $pnpmVersion is available(from shim)" -ForegroundColor Green
      } else {
        Write-Host "‚ö†Ô∏è  pnpm command may need troubleshooting(from shim)" -ForegroundColor Yellow
      }
    }
    catch {
      Write-Host "‚ö†Ô∏è  pnpm is not working: $_" -ForegroundColor Yellow
    }
  }
  # Verify wasm-opt availability and version
  try {
    $wasmOptVersion = & $script:WasmOptExe --version
    if ($wasmOptVersion) {
      Write-Host "‚úÖ wasm-opt version: $wasmOptVersion" -ForegroundColor Green
    } else {
      Write-Host "‚ö†Ô∏è wasm-opt found, but version check failed" -ForegroundColor Yellow
    }
  } catch {
    try {
      #Assuming Shim is caught so extracting the real .exe/.cmd
      $shim = (Get-Command wasmopt).Path
      $real = Resolve-ShimTarget $shim
      $script:WasmOptExe = $real
      Set-Alias wasmopt  Invoke-WasmOpt  -Force
      $wasmOptVersion = & wasmopt --version 2>$null
      if ($wasmOptVersion) {
        Write-Host "‚úÖ wasm-opt version: $wasmOptVersion" -ForegroundColor Green
      } else {
        Write-Host "‚ö†Ô∏è wasm-opt found, but version check failed" -ForegroundColor Yellow
      }
    }
    catch {
      Write-Host "‚ö†Ô∏è  wasm-opt is not working: $_" -ForegroundColor Yellow
    }
  }
}

# Quick helper functions for common tasks
function Test-NodePnpmSetup {
  Write-Host "`nüîç Testing Node.js & pnpm setup..." -ForegroundColor Cyan
  @{ Node=node; pnpm=pnpm } | ForEach-Object {
    $cmd = $_.Value
    if (Get-Command $cmd -ErrorAction SilentlyContinue) {
      Write-Host "  Command: $($cmd.Source)" -ForegroundColor White
      Write-Host "  ‚úÖ $($cmd): $( & $cmd --version )" -ForegroundColor Green
    } else {
      Write-Host "  ‚ùå $cmd not found" -ForegroundColor Red
    }
  } 
    Write-Host "`nPATH entries related to Node.js/pnpm:" -ForegroundColor Yellow
    $env:PATH -split ';' | Where-Object { $_ -like '*node*' -or $_ -like '*pnpm*' -or $_ -like '*npm*' } | ForEach-Object {
        Write-Host "  $_" -ForegroundColor White
    }
}

Set-Alias -Name "test-setup" -Value "Test-NodePnpmSetup"

if ($Host.Name -eq 'ConsoleHost') {
	Write-Verbose "Use 'test-setup' to verify Node.js and pnpm configuration"
}

#Powershell 5.1 Compatibility Extensions

# ‚îÄ‚îÄ Only define compatibility helpers when running PS Core (6+) ‚îÄ‚îÄ
if ($PSVersionTable.PSEdition -eq 'Core') {

  # Auto-import Windows PowerShell modules through a PS 5.1 process
  function Import-WindowsModule {
    param([string]$Name)
    Import-Module $Name -UseWindowsPowerShell -ErrorAction Stop
  }

  # Explicit loader functions (more reliable than aliasing a scriptblock)
  function Load-ActiveDirectory    { Import-WindowsModule ActiveDirectory }
  function Load-DnsClient          { Import-WindowsModule DnsClient }
  function Load-GroupPolicy        { Import-WindowsModule GroupPolicy }
  function Load-DHCPServer         { Import-WindowsModule DHCPServer }
  function Load-FailoverClusters   { Import-WindowsModule FailoverClusters }

  # Bring back PS 5.1 shorthands in PS Core
  Set-Alias Where   Where-Object      -Option AllScope
  Set-Alias Foreach ForEach-Object    -Option AllScope
  Set-Alias Invoke  Invoke-Command    -Option AllScope
  Set-Alias IEX     Invoke-Expression -Option AllScope

  # Batch loader if you need more in one go
  function Load-WindowsModules {
    param([string[]]$Modules)
    foreach ($m in $Modules) { Import-WindowsModule $m }
  }

}

### Final Banner ###
if ($Host.Name -eq 'ConsoleHost') {
  # Use the actual $nodePath/$pnpmPath variables you defined above
  $nodeVer = try { & node --version } catch { 'n/a' }
  $pnpmVer = try { & pnpm --version } catch { 'n/a' }

  Write-Host (
    "Profile loaded: UTF8 ‚úî Copilot ‚úî " +
    "Node.js: $nodeVer pnpm: $pnpmVer"
  ) -ForegroundColor Cyan
}
