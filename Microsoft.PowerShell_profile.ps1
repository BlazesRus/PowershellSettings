<#
# Reusable PowerShell Profile Configuration for Better GitHub Copilot Integration
# Enhanced with Node.js and pnpm support
  Original version generated by James Armstrong(github.com/BlazesRus) with GitHub Copilot assistance for Powershell 7 
	(reusablable version generated with Microsoft copilot assistance)
  - Place this script at: $PROFILE (e.g. $HOME\Documents\PowerShell\Microsoft.PowerShell_profile.ps1)
  - Customize only under ‚Äú# Configuration‚Äù as needed.
#>

if (-not $HOME) { $HOME = $env:USERPROFILE }

# UTF-8 encoding configuration for Windows
[Console]::OutputEncoding = [Text.UTF8Encoding]::new()
[Console]::InputEncoding = [Text.UTF8Encoding]::new()
$PSDefaultParameterValues['*:Encoding'] = 'utf8'


# In your profile script
#  - On PS5.1: Test-Path variable:IsWindows is false ‚Üí -not false = true ‚Üí Windows
#  - On PS Core/Windows: Test-Path true AND $IsWindows true ‚Üí true
#  - On PS Core/Linux/macOS: Test-Path true AND $IsWindows false ‚Üí false

$runningOnWindows = $PSHOME -match '\\WindowsPowerShell\\'

if ($runningOnWindows) {
  # Set console code page to UTF-8
  try { chcp 65001 | Out-Null } catch {}
}

# Ensure prompt loads quickly to prevent Copilot timing out
$ErrorActionPreference = "SilentlyContinue"

### Utility: Find-Executable ###

# 1) Locate the actual .exe or .cmd shim
function Find-ExecutablePath {
  param(
    [Parameter(Mandatory)] [string]   $Name,
    [string[]]                       $SearchPaths
  )

  # a) Anything on PATH already?
  if ($c = Get-Command $Name -ErrorAction SilentlyContinue) {
    return $c.Path
  }

  # b) Fallback scan
  $exts = if ($runningOnWindows) { '.cmd','.exe' } else { '' }
  foreach ($ext in $exts) {
    foreach ($dir in $SearchPaths) {
      $f = Join-Path $dir "$Name$ext"
      if (Test-Path $f) { return (Resolve-Path $f).Path }
    }
  }
  return $null
}

# 2) Extract the folder
function Find-ExecutableFolder {
  param(
    [Parameter(Mandatory)] [string]   $Name,
    [string[]]                       $SearchPaths
  )

  $path = Find-ExecutablePath -Name $Name -SearchPaths $SearchPaths
  return if ($path) { Split-Path $path -Parent } else { $null }
}

### Configuration ###
# List of potential Node/pnpm root paths to scan (in order)
$Global:NodeSearchPaths = @(
  "$HOME\AppData\Roaming\npm",                           # Windows npm default(Most likely location)
  (npm root -g | Split-Path -Parent),                   # npm global modules root
  "$env:ProgramFiles\nodejs",                            # Node installer
  "/usr/local/bin",                                      # macOS/Linux default
  "/usr/bin"
)

$Global:pnpmSearchPaths = @(
  "$HOME\AppData\Local\pnpm",                           # Windows npm default (Most likely location)
  "/usr/local/bin",                                      # macOS/Linux default
  "/usr/bin"
)

# Node.js and pnpm Path Configuration
# Add Node.js and pnpm to PATH if not already present

$nodePath   = Find-ExecutablePath   -Name node  -SearchPaths $Global:NodeSearchPaths
$pnpmPath   = Find-ExecutablePath   -Name pnpm  -SearchPaths $Global:pnpmSearchPaths
$nodeFolder = Find-ExecutableFolder -Name node  -SearchPaths $Global:NodeSearchPaths
$pnpmFolder = Find-ExecutableFolder -Name pnpm  -SearchPaths $Global:pnpmSearchPaths

# 5) Also include npm‚Äôs true global bin (where shims live)
try { $npmBin = (npm bin -g).Trim() } catch {}

# 6) Prepend each folder once
@($nodeFolder,$pnpmFolder,$npmBin) |
  Where-Object { $_ -and (Test-Path $_) } |
  ForEach-Object {
    if ($env:PATH -notmatch [regex]::Escape($_)) {
      $env:PATH = "$_;$env:PATH"
      Write-Host "Added to PATH: $_" -ForegroundColor Green
    }
  }

# 7) Invocation wrappers
#Cache Shim Paths
$script:NodeExe  = $nodePath
$script:PnpmExe  = $pnpmPath

# Then in wrapper:
function Invoke-Node { & $script:NodeExe @Args }
function Invoke-Pnpm { & $script:PnpmExe @Args }

if (-not (Get-Command node -CommandType Any -ErrorAction SilentlyContinue)) {
    Set-Alias node  Invoke-Node  -Force
}
Set-Alias pnpm Invoke-Pnpm -Force

# Set up shell integration markers for better command detection
function prompt {
    # Add shell integration markers that help Copilot detect command completion

    # ANSI sequences
    $ESC = [char]27
    $BEL = [char]7

    # Command started marker
    Write-Host "$ESC]133;C$BEL" -NoNewline

    # Standard prompt
    $path = Get-Location
    $gitBranch = ""

    # Quick git branch detection (if in git repo)
    if (Test-Path ".git") {
        try {
            $gitBranch = " ($(git branch --show-current 2>$null))"
        } catch {}
    }

    # Command finished marker
    Write-Host "$ESC]133;D;$LASTEXITCODE$BEL" -NoNewline

    return "PS $path$gitBranch> "
}

# Improve command completion detection
if ($null -ne $script:ExitEvent) {
  Unregister-Event -SubscriptionId $script:ExitEvent
}

$script:ExitEvent = Register-EngineEvent -SourceIdentifier PowerShell.Exiting -Action {
    $ESC = [char]27
    $BEL = [char]7
    Write-Host "$ESC]133;D;$LASTEXITCODE$BEL" -NoNewline
}

# Set console title for better terminal identification
$Host.UI.RawUI.WindowTitle = "PowerShell - GitHub Copilot Enhanced (Node.js Ready)"

# Improve readline experience
if (Get-Module -ListAvailable PSReadLine) {
    Import-Module PSReadLine
    Set-PSReadLineOption -PredictionSource History
    Set-PSReadLineOption -HistorySearchCursorMovesToEnd
    Set-PSReadLineKeyHandler -Key Tab -Function Complete
}

# Quick function to signal command completion to Copilot
function Send-CompletionSignal {
    $ESC = [char]27
    $BEL = [char]7
    Write-Host "$ESC]133;D;0$BEL" -NoNewline
    Write-Host "`nCommand completed successfully." -ForegroundColor Green
}

# Alias for easy use
Set-Alias -Name "done" -Value "Send-CompletionSignal"

# Test Node.js and pnpm availability on profile load
if ($Host.Name -eq 'ConsoleHost') {
  Write-Host "PowerShell profile loaded - GitHub Copilot integration enhanced" -ForegroundColor Cyan

	# Verify Node.js and pnpm are working
	try {
			$nodeVersion = & node --version 2>$null
			if ($nodeVersion) {
					Write-Host "‚úÖ Node.js $nodeVersion is available" -ForegroundColor Green
			} else {
					Write-Host "‚ö†Ô∏è  Node.js command may need troubleshooting" -ForegroundColor Yellow
			}
	} catch {
			Write-Host "‚ö†Ô∏è  Node.js is not working: $_" -ForegroundColor Yellow
	}

	try {
			$pnpmVersion = & pnpm --version 2>$null
			if ($pnpmVersion) {
					Write-Host "‚úÖ pnpm $pnpmVersion is available" -ForegroundColor Green
			} else {
					Write-Host "‚ö†Ô∏è  pnpm command may need troubleshooting" -ForegroundColor Yellow
			}
	} catch {
			Write-Host "‚ö†Ô∏è  pnpm is not working: $_" -ForegroundColor Yellow
	}
}

# Quick helper functions for common tasks
function Test-NodePnpmSetup {
  Write-Host "`nüîç Testing Node.js & pnpm setup..." -ForegroundColor Cyan
  @{ Node=node; pnpm=pnpm } | ForEach-Object {
    $cmd = $_.Value
    if (Get-Command $cmd -ErrorAction SilentlyContinue) {
      Write-Host "  Command: $($cmd.Source)" -ForegroundColor White
      Write-Host "  ‚úÖ $cmd: $(& $cmd --version)" -ForegroundColor Green
    } else {
      Write-Host "  ‚ùå $cmd not found" -ForegroundColor Red
    }
  } 
    Write-Host "`nPATH entries related to Node.js/pnpm:" -ForegroundColor Yellow
    $env:PATH -split ';' | Where-Object { $_ -like '*node*' -or $_ -like '*pnpm*' -or $_ -like '*npm*' } | ForEach-Object {
        Write-Host "  $_" -ForegroundColor White
    }
}

Set-Alias -Name "test-setup" -Value "Test-NodePnpmSetup"

if ($Host.Name -eq 'ConsoleHost') {
	Write-Host "Use 'test-setup' to verify Node.js and pnpm configuration" -ForegroundColor Gray
}

#Powershell 5.1 Compatibility Extensions

# Auto-import Windows PowerShell modules when needed
function Import-WindowsModule {
    param([string]$Name)
    Import-Module $Name -UseWindowsPowerShell -ErrorAction Stop
}

# Example: load ActiveDirectory from PS5.1 on demand
Set-Alias Load-ADModule { Import-WindowsModule ActiveDirectory }


### Final Banner ###
if ($Host.Name -eq 'ConsoleHost') {
	Write-Host "Profile loaded: UTF8 ‚úî Copilot ‚úî Node.js: $($nodeJsPath -and (& node --version)) pnpm: $($pnpmPath -and (& pnpm --version))" -ForegroundColor Cyan
}