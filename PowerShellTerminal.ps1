<#
# Reusable PowerShell Profile Configuration for Better GitHub Copilot Integration
# Enhanced with Node.js and pnpm support
# Original version generated by James Armstrong(github.com/BlazesRus)
# with GitHub Copilot assistance for Powershell 7
# (reusablable version generated with Microsoft Copilot assistance)
 - To use as user PowerShellProfile place this script at: $PROFILE (e.g. $HOME\Documents\PowerShell\Microsoft.PowerShell_profile.ps1)
 - Place PowerShellSettings folder inside project folder to use as a terminal setting(code-workspace file setting):
     "terminal.integrated.profiles.windows": {
       "PowerShell 7": {
        "path": [
          "${env:ProgramFiles}\\PowerShell\\7\\pwsh.exe",
          "${env:ProgramFiles(x86)}\\PowerShell\\7\\pwsh.exe",
          "pwsh.exe"
        ],
        "icon": "terminal-powershell",
        "args": [
          "-NoLogo",
          "-NoExit",
          "-ExecutionPolicy", "Bypass",
          "-Command",
          "& \"${workspaceFolder:projectroot}/PowershellSettings/PowerShellTerminal.ps1\""
        ],
        "overrideName": true
      },
    },
    "terminal.integrated.defaultProfile.windows": "PowerShell 7",
    "terminal.integrated.automationProfile.windows": "PowerShell 7",
 - Customize ProfileSettings.psd1 for custom variables
 
File under
MIT No Attribution License (MIT-0)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#>

if($env:USERPROFILE){
  #Write-Host "`$env:USERPROFILE: [$env:USERPROFILE]"
}
if($env:HOME){
  #Write-Host "`$env:HOME: [$env:HOME]"
  if (-not $HOME) { $HOME = $env:HOME }
}
elseif($HOME){
 #Write-Host "`$HOME: [$HOME]"
}
elseif($env:USERPROFILE){ $HOME = $env:USERPROFILE }
else { Write-Host "Home variable does not exist" }

# In your profile script
#  - On PS5.1: Test-Path variable:IsWindows is false → -not false = true → Windows
#  - On PS Core/Windows: Test-Path true AND $IsWindows true → true
#  - On PS Core/Linux/macOS: Test-Path true AND $IsWindows false → false

<# #Don't need any PowerShell 5.1 specific code at moment(keeping in comments in case use later)
$runningOnPS5  = $PSVersionTable.PSEdition -eq 'Desktop'
#Ensure it really is v5
if ($runningOnPS5 -and $PSVersionTable.PSVersion.Major -ne 5) {
  $runningOnPS5 = $false
}
#>

#runningOnPSCore
$OnPSCore = $PSVersionTable.PSEdition -eq 'Core'
#runningOnWindows
# Cross-version Windows detection:
$OnWindows = if (Test-Path Variable:IsWindows) {
    # PS Core → use the built-in boolean
    $IsWindows
} else {
    # PS5.1 → its $PSHOME path always contains “WindowsPowerShell”
    $PSHOME -match '\\WindowsPowerShell\\'
}
$IsInteractiveHost = $Host.Name -eq 'ConsoleHost'

$scriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path
Write-Host "PSScriptRoot = $PSScriptRoot scriptRoot = $scriptRoot"

$settingsFile = Join-Path -Path $scriptRoot -ChildPath 'ProfileSettings.psd1'
$settings     = Import-PowerShellDataFile $settingsFile

if($settings.forceUTF8){
	# UTF-8 encoding configuration for Windows
	[Console]::OutputEncoding = [Text.UTF8Encoding]::new()
	[Console]::InputEncoding = [Text.UTF8Encoding]::new()

	if($settings.useBOM){
		$PSDefaultParameterValues['*:Encoding'] = 'utf8BOM'
		$PSDefaultParameterValues['Out-File:Encoding']      = 'utf8BOM'
		$PSDefaultParameterValues['Set-Content:Encoding']    = 'utf8BOM'
		$PSDefaultParameterValues['Add-Content:Encoding']    = 'utf8BOM'
		$PSDefaultParameterValues['Export-Csv:Encoding']     = 'utf8BOM'
	}
	else {
		$PSDefaultParameterValues['*:Encoding'] = 'utf8NoBOM'
		$PSDefaultParameterValues['Out-File:Encoding']      = 'utf8NoBOM'
		$PSDefaultParameterValues['Set-Content:Encoding']    = 'utf8NoBOM'
		$PSDefaultParameterValues['Add-Content:Encoding']    = 'utf8NoBOM'
		$PSDefaultParameterValues['Export-Csv:Encoding']     = 'utf8NoBOM'
	}
	$PSDefaultParameterValues['ConvertTo-Json:Depth']    = 5  # JSON depth tweak, optional
}

if ($OnWindows -and $settings.forceUTF8) {
  if ($PSVersionTable.PSEdition -eq 'Desktop') {
    try { chcp 65001 | Out-Null } catch {}
  }

  if ($env:LANG -match '^en' -or $lang -eq 'en') {
    $env:LANG = "en_US.UTF-8"
  }
}
elseif ($settings.forceUTF8){
  # On *nix, ensure LANG starts with "en"
  if ($env:LANG -match '^en') {
    $env:LANG = "en_US.UTF-8"
  }
}

# Ensure prompt loads quickly to prevent Copilot timing out
$ErrorActionPreference = "SilentlyContinue"

#Manually run corepack enable in console

# ─────────────────────────────────────────────────────────────────────────────
# Shell‐integration markers for Copilot completion detection
# ─────────────────────────────────────────────────────────────────────────────

# Tear down any old exit‐event first
Get-EventSubscriber -SourceIdentifier PowerShell.Exiting |
  Unregister-Event

# Register a fresh exit event
Register-EngineEvent `
  -SourceIdentifier PowerShell.Exiting `
  -Action {
    $ESC = [char]27
    $BEL = [char]7
    Write-Host "$ESC]133;D;$LASTEXITCODE$BEL" -NoNewline
  } | Out-Null

function prompt {
    # ANSI sequences
    $ESC = [char]27
    $BEL = [char]7

    # Command started marker
    Write-Host "$ESC]133;C$BEL" -NoNewline

    # Standard prompt
    $path = Get-Location
    $gitBranch = ""

    # Quick git branch detection (if in git repo)
    if (Test-Path ".git") {
        try {
            $gitBranch = " ($(git branch --show-current 2>$null))"
        } catch {}
    }

    # Command finished marker
    Write-Host "$ESC]133;D;$LASTEXITCODE$BEL" -NoNewline

    return "PS $path$gitBranch> "
}

# Set console title for better terminal identification
$Host.UI.RawUI.WindowTitle = "PowerShell - GitHub Copilot Enhanced"

# Improve readline experience
if (Get-Module -ListAvailable PSReadLine) {
    Import-Module PSReadLine
    Set-PSReadLineOption -PredictionSource History
    Set-PSReadLineOption -HistorySearchCursorMovesToEnd
    Set-PSReadLineKeyHandler -Key Tab -Function Complete
}

# Quick function to signal command completion to Copilot
function Send-CompletionSignal {
    $ESC = [char]27
    $BEL = [char]7
    Write-Host "$ESC]133;D;0$BEL" -NoNewline
    Write-Host "`nCommand completed successfully." -ForegroundColor Green
}

# Alias for easy use
Set-Alias -Name "done" -Value "Send-CompletionSignal"

# Only apply shim logic in PS Core on Windows($IsWindows is null in PowerShell 5.1)
if ($OnPSCore -and $IsWindows) {
	#Force PowerShell 7 to Use the “.cmd” shims instead of ps1 files
	if($settings.forceCmdShims){
		# ─────────────────────────────────────────────────────────────────────────────
		# 1. Prepend Node.js install folder (so pnpm.cmd / npm.cmd are found first)
		# ─────────────────────────────────────────────────────────────────────────────
		if ($node = Get-Command node.exe -ErrorAction SilentlyContinue) {
				$nodeDir = Split-Path $node.Source
				if (-not ($env:Path -split ';' | Where-Object { $_ -eq $nodeDir })) {
						# Prepend, so Node’s shim dir wins
						$env:Path = "$nodeDir;$env:Path"
				}
		}

		# ─────────────────────────────────────────────────────────────────────────────
		# 2. Bump .CMD ahead of .PS1 in PATHEXT (skip unsigned .ps1 shims)
		# ─────────────────────────────────────────────────────────────────────────────
		$exts = $env:PATHEXT -split ';' | Where-Object { $_ -ne '.PS1' }
		$env:PATHEXT = '.CMD;' + ($exts -join ';')

		# ─────────────────────────────────────────────────────────────────────────────
		# 3. Explicit wrapper functions for pnpm and wasm-opt
		# ─────────────────────────────────────────────────────────────────────────────
		if (Get-Command pnpm.cmd -ErrorAction SilentlyContinue) {
			function pnpm {
				& (Get-Command pnpm.cmd).Source @args
			}
		}

		if (Get-Command wasm-opt.cmd -ErrorAction SilentlyContinue) {
			function wasm-opt {
				& (Get-Command wasm-opt.cmd).Source @args
			}
		}
	}

  #Powershell 5.1 Compatibility Extensions
  # Auto-import Windows PowerShell modules through a PS 5.1 process
  function Import-WindowsModule {
    param([string]$Name)
    Import-Module $Name -UseWindowsPowerShell -ErrorAction Stop
  }

  # Explicit loader functions (more reliable than aliasing a scriptblock)
  function Load-ActiveDirectory    { Import-WindowsModule ActiveDirectory }
  function Load-DnsClient          { Import-WindowsModule DnsClient }
  function Load-GroupPolicy        { Import-WindowsModule GroupPolicy }
  function Load-DHCPServer         { Import-WindowsModule DHCPServer }
  function Load-FailoverClusters   { Import-WindowsModule FailoverClusters }

  # Bring back PS 5.1 shorthands in PS Core
  Set-Alias Where   Where-Object      -Option AllScope
  Set-Alias Foreach ForEach-Object    -Option AllScope
  Set-Alias Invoke  Invoke-Command    -Option AllScope
  Set-Alias IEX     Invoke-Expression -Option AllScope

  # Batch loader if you need more in one go
  function Load-WindowsModules {
    param([string[]]$Modules)
    foreach ($m in $Modules) { Import-WindowsModule $m }
  }

  #Place other $OnPSCore -and $IsWindows optimizations here
}

if ($cmd = Get-Command wasm-opt -ErrorAction SilentlyContinue) {
	function wasm-opt {
		& (Get-Command wasm-opt.cmd).Source @args
	}
	#Alias function in case - part of name messes up scripts
	function wasmOpt {
		& $cmd.Source @args
	}
  $versionOutput = & wasm-opt --version
	#saving as global to simplify version check
  if ($versionOutput -match '(\d+)') {
    $global:wasmOptVer = [int]$Matches[1]
  } else {
    Write-Warning "Unable to parse wasm-opt version from: '$versionOutput'."
    $global:wasmOptVer = 0
  }
	$aliasTest = & wasmOpt --version
  if ($versionOutput -match '(\d+)') {
  } else {
    Write-Warning "Unable to parse wasmOpt version from: & wasmOpt --version."
  }
}
else {
  Write-Host "wasmOpt alias failed."
}

#Normalizes a candidate path
#Checks if it already exists in $env:Path
#If present, removes the old entry and re-prepends it
#If missing, simply prepends it
function Prepend-PathEntry {
    param(
        [Parameter(Mandatory)]
        [string]$Entry
    )

    # Normalize directory (remove trailing slash)
    $norm = [IO.Path]::TrimEndingDirectorySeparator((Resolve-Path $Entry).ProviderPath)

    # Split current PATH into an array
    $parts = $env:Path -split ';'

    # Filter out any existing occurrence (case-insensitive on Windows)
    $filtered = $parts |
        Where-Object { -not ($_.TrimEnd('\') -ieq $norm) }

    # Rebuild PATH with our entry at the front
    $env:Path = "$norm;{0}" -f ($filtered -join ';')
}

if($setting.enableTinyGoFix){
    $tinygoExe              = $settings.tinygoExe
    $goRoot                 = $settings.goRoot
    if (Test-Path $tinygoExe) {
      $global.hasDirectTinyGo = $true
    }
		else {
      $global.hasDirectTinyGo = $false
		}
    if (-not (Get-Command go -ErrorAction SilentlyContinue) -and (Test-Path $goRoot)) {
      Prepend-PathEntry goRoot
      Write-Host "Prepended $goRoot to PATH to satisfy TinyGo’s go dependency" -ForegroundColor Cyan
    }
}

if (-not $OnPSCore) {
  if($OnWindows -and $settings.forceCmdShims){
    if (Get-Command wasm-opt.cmd -ErrorAction SilentlyContinue) {
        function wasm-opt { & (Get-Command wasm-opt.cmd).Source @args }
    }
	}

	#https://stackoverflow.com/questions/10623907/null-coalescing-in-powershell
	#null-coalescing operator emulation for Powershell 5.1
	# Usage with scriptblocks to delay execution:
  #$s = NullCheck { $myval } { Get-ExpensiveValue }
	function NullCheck {
		param(
			[scriptblock]$Left,
			[scriptblock]$Right
		)
		if (& $Left) { & $Left }
		else { & $Right }
	}
}

### Final Banner ###
if ($IsInteractiveHost) {
  # Use the actual $nodePath/$pnpmPath variables you defined above
  $nodeVer = try { & node --version } catch { 'n/a' }
  $pnpmVer = try { & pnpm --version } catch { 'n/a' }

  Write-Host (
    "Profile loaded: UTF8 ✔ Copilot ✔ " +
    "Node.js: $nodeVer pnpm: $pnpmVer wasm-opt: $global:wasmOptVer"
  ) -ForegroundColor Cyan
}
